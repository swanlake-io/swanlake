use reqwest::blocking::Client;
use std::env;
use std::fs;
use std::io::Cursor;
use std::path::{Path, PathBuf};
use std::time::Duration;
use zip::ZipArchive;

const FALLBACK_DUCKDB_VERSION: &str = "1.4.4";

fn main() {
    println!("cargo:rerun-if-env-changed=DUCKDB_VERSION");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let version = resolve_duckdb_version(&manifest_dir);
    let cache_dir = manifest_dir.join(".duckdb");
    let install_dir = cache_dir.join(&version);
    let env_file = cache_dir.join("env.sh");

    let client = Client::builder()
        .timeout(Duration::from_secs(600))
        .build()
        .unwrap();

    let dist = detect_dist().expect("Unsupported platform");
    let zip_name = format!("libduckdb-{}.zip", dist);
    let download_url = format!(
        "https://github.com/duckdb/duckdb/releases/download/v{}/{}",
        version, zip_name
    );

    fs::create_dir_all(&install_dir).unwrap();
    env::set_current_dir(&install_dir).unwrap();

    if !Path::new(&zip_name).exists() {
        println!("cargo:warning=Downloading DuckDB {} ({})...", version, dist);
        let response = client
            .get(&download_url)
            .send()
            .expect("Failed to download DuckDB");
        let bytes = response.bytes().expect("Failed to read response bytes");
        fs::write(&zip_name, bytes).expect("Failed to write zip file");
    } else {
        println!("cargo:warning=Using cached archive {}", zip_name);
    }

    // Check for platform-specific library
    let lib_name = if cfg!(target_os = "macos") {
        "libduckdb.dylib"
    } else {
        "libduckdb.so"
    };
    let lib_exists = Path::new(lib_name).exists();
    println!(
        "cargo:debug=Checking for library in {}: {} exists = {}",
        install_dir.display(),
        lib_name,
        lib_exists
    );

    if !lib_exists {
        println!("cargo:warning=Extracting {}...", zip_name);
        let file = fs::File::open(&zip_name).unwrap();
        let mut archive = ZipArchive::new(file).unwrap();
        println!("cargo:debug=Archive contains {} files", archive.len());
        for i in 0..archive.len() {
            let mut file = archive.by_index(i).unwrap();
            let outpath = match file.enclosed_name() {
                Some(path) => path,
                None => continue,
            };
            println!("cargo:debug=Extracting: {}", outpath.display());
            if file.is_dir() {
                fs::create_dir_all(&outpath).unwrap();
            } else {
                if let Some(p) = outpath.parent() {
                    if !p.exists() {
                        fs::create_dir_all(p).unwrap();
                    }
                }
                let mut outfile = fs::File::create(&outpath).unwrap();
                let bytes_copied = std::io::copy(&mut file, &mut outfile).unwrap();
                println!("cargo:debug=  -> wrote {} bytes", bytes_copied);
            }
        }
        println!(
            "cargo:debug=Extraction complete. {} exists = {}",
            lib_name,
            Path::new(lib_name).exists()
        );
    } else {
        println!("cargo:warning=Using cached library files");
    }

    // List directory contents for debugging
    println!(
        "cargo:debug=Directory contents of {}:",
        install_dir.display()
    );
    if let Ok(entries) = fs::read_dir(&install_dir) {
        for entry in entries.flatten() {
            println!("cargo:debug=  - {}", entry.path().display());
        }
    }

    if !Path::new("duckdb.h").exists() {
        println!("cargo:warning=duckdb.h missing from archive; attempting to download...");
        let headers_url = format!(
            "https://github.com/duckdb/duckdb/releases/download/v{}/duckdb-{}.zip",
            version, dist
        );
        let response = client
            .get(&headers_url)
            .send()
            .expect("Failed to download headers");
        let bytes = response.bytes().unwrap();
        let cursor = Cursor::new(bytes);
        let mut archive = ZipArchive::new(cursor).unwrap();
        for i in 0..archive.len() {
            let mut file = archive.by_index(i).unwrap();
            if let Some(enclosed_name) = file.enclosed_name() {
                if enclosed_name == Path::new("duckdb.h")
                    || enclosed_name == Path::new("duckdb.hpp")
                {
                    let mut outfile = fs::File::create(&enclosed_name).unwrap();
                    std::io::copy(&mut file, &mut outfile).unwrap();
                }
            }
        }
    }

    let lib_dir = install_dir.display();
    let mut env_content = "# Generated by build.rs\n".to_string();
    env_content.push_str(&format!("export DUCKDB_VERSION='{}'\n", version));
    env_content.push_str(&format!(
        "export DUCKDB_PREFIX=\"${{DUCKDB_PREFIX:-{}}}\"\n",
        cache_dir.display()
    ));
    env_content.push_str("export DUCKDB_LIB_DIR=\"${DUCKDB_PREFIX}/${DUCKDB_VERSION}\"\n");
    env_content.push_str("export DUCKDB_INCLUDE_DIR=\"${DUCKDB_LIB_DIR}\"\n");
    match dist.as_str() {
        "osx-universal" => {
            env_content.push_str(
                "export DYLD_FALLBACK_LIBRARY_PATH=\"${DUCKDB_LIB_DIR}:${DYLD_FALLBACK_LIBRARY_PATH:-}\"\n",
            );
        }
        "linux-amd64" | "linux-arm64" => {
            env_content
                .push_str("export LD_LIBRARY_PATH=\"${DUCKDB_LIB_DIR}:${LD_LIBRARY_PATH:-}\"\n");
        }
        _ => {}
    }
    fs::write(&env_file, env_content).unwrap();

    // Propagate metadata to dependent crates for easier runtime linking
    println!("cargo:lib_dir={}", install_dir.display());
    println!("cargo:env_file={}", env_file.display());
    println!("cargo:duckdb_version={}", version);

    println!(
        "cargo:warning=DuckDB {} ready at {}",
        version,
        install_dir.display()
    );

    // Set Cargo link paths for dynamic linking
    println!("cargo:rustc-link-search=native={}", lib_dir);
    println!("cargo:rustc-link-lib=dylib=duckdb");
    println!("cargo:rustc-link-arg=-Wl,-rpath,{}", lib_dir);
}

fn detect_dist() -> Result<String, String> {
    let os = env::consts::OS;
    let arch = env::consts::ARCH;
    match os {
        "macos" => match arch {
            "aarch64" | "x86_64" => Ok("osx-universal".to_string()),
            _ => Err(format!("Unsupported macOS architecture: {}", arch)),
        },
        "linux" => match arch {
            "x86_64" => Ok("linux-amd64".to_string()),
            "aarch64" => Ok("linux-arm64".to_string()),
            _ => Err(format!("Unsupported Linux architecture: {}", arch)),
        },
        _ => Err(format!("Unsupported operating system: {}", os)),
    }
}

fn resolve_duckdb_version(manifest_dir: &Path) -> String {
    if let Ok(version) = env::var("DUCKDB_VERSION") {
        return version;
    }

    if let Some(lock_path) = find_cargo_lock(manifest_dir) {
        println!("cargo:rerun-if-changed={}", lock_path.display());
        if let Some(version) = duckdb_version_from_lock(&lock_path) {
            return version;
        }
        println!(
            "cargo:warning=Unable to infer DuckDB version from {}; falling back to {}",
            lock_path.display(),
            FALLBACK_DUCKDB_VERSION
        );
    } else {
        println!(
            "cargo:warning=Unable to locate Cargo.lock; falling back to {}",
            FALLBACK_DUCKDB_VERSION
        );
    }

    FALLBACK_DUCKDB_VERSION.to_string()
}

fn find_cargo_lock(manifest_dir: &Path) -> Option<PathBuf> {
    manifest_dir
        .ancestors()
        .map(|dir| dir.join("Cargo.lock"))
        .find(|candidate| candidate.is_file())
}

fn duckdb_version_from_lock(lock_path: &Path) -> Option<String> {
    let lock = fs::read_to_string(lock_path).ok()?;
    let mut current_name: Option<String> = None;
    let mut current_version: Option<String> = None;
    let mut best_version: Option<String> = None;

    for line in lock.lines().map(str::trim) {
        if line == "[[package]]" {
            if current_name.as_deref() == Some("libduckdb-sys") {
                best_version = pick_newer_version(best_version, current_version.take());
            }
            current_name = None;
            current_version = None;
            continue;
        }

        if let Some(name) = parse_quoted_kv(line, "name") {
            current_name = Some(name);
            continue;
        }

        if let Some(version) = parse_quoted_kv(line, "version") {
            current_version = Some(version);
        }
    }

    if current_name.as_deref() == Some("libduckdb-sys") {
        best_version = pick_newer_version(best_version, current_version);
    }

    best_version
}

fn parse_quoted_kv(line: &str, key: &str) -> Option<String> {
    let prefix = format!("{key} = \"");
    if !line.starts_with(&prefix) {
        return None;
    }
    line.strip_prefix(&prefix)?
        .strip_suffix('"')
        .map(|s| s.to_string())
}

fn pick_newer_version(current: Option<String>, candidate: Option<String>) -> Option<String> {
    match (current, candidate) {
        (None, Some(candidate)) => Some(candidate),
        (Some(current), None) => Some(current),
        (None, None) => None,
        (Some(current), Some(candidate)) => {
            match (semver_triplet(&current), semver_triplet(&candidate)) {
                (Some(a), Some(b)) if b > a => Some(candidate),
                _ => Some(current),
            }
        }
    }
}

fn semver_triplet(version: &str) -> Option<(u64, u64, u64)> {
    let core = version.split_once('-').map(|(v, _)| v).unwrap_or(version);
    let mut parts = core.split('.');
    let major = parts.next()?.parse().ok()?;
    let minor = parts.next()?.parse().ok()?;
    let patch = parts.next()?.parse().ok()?;
    Some((major, minor, patch))
}
