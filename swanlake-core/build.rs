use reqwest::blocking::Client;
use std::env;
use std::fs;
use std::io::{self, Cursor, Write};
use std::path::{Path, PathBuf};
use std::time::Duration;
use zip::ZipArchive;

const FALLBACK_DUCKDB_VERSION: &str = "1.4.4";

type BuildResult<T> = Result<T, Box<dyn std::error::Error>>;

fn emit(line: impl AsRef<str>) -> io::Result<()> {
    let mut stdout = io::stdout().lock();
    writeln!(stdout, "{}", line.as_ref())
}

fn main() -> BuildResult<()> {
    emit("cargo:rerun-if-env-changed=DUCKDB_VERSION")?;

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let version = resolve_duckdb_version(&manifest_dir)?;
    let cache_dir = manifest_dir.join(".duckdb");
    let install_dir = cache_dir.join(&version);
    let env_file = cache_dir.join("env.sh");
    let mut client: Option<Client> = None;

    let dist = detect_dist()?;
    let zip_name = format!("libduckdb-{dist}.zip");
    let download_url =
        format!("https://github.com/duckdb/duckdb/releases/download/v{version}/{zip_name}");

    fs::create_dir_all(&install_dir)?;
    env::set_current_dir(&install_dir)?;

    if Path::new(&zip_name).exists() {
        emit(format!("cargo:warning=Using cached archive {zip_name}"))?;
    } else {
        emit(format!(
            "cargo:warning=Downloading DuckDB {version} ({dist})..."
        ))?;
        let response = ensure_http_client(&mut client)?.get(&download_url).send()?;
        let bytes = response.bytes()?;
        fs::write(&zip_name, bytes)?;
    }

    let lib_name = if cfg!(target_os = "macos") {
        "libduckdb.dylib"
    } else {
        "libduckdb.so"
    };
    let lib_exists = Path::new(lib_name).exists();
    emit(format!(
        "cargo:debug=Checking for library in {install_dir}: {lib_name} exists = {lib_exists}",
        install_dir = install_dir.display()
    ))?;

    if lib_exists {
        emit("cargo:warning=Using cached library files")?;
    } else {
        emit(format!("cargo:warning=Extracting {zip_name}..."))?;
        let file = fs::File::open(&zip_name)?;
        let mut archive = ZipArchive::new(file)?;
        emit(format!(
            "cargo:debug=Archive contains {archive_len} files",
            archive_len = archive.len()
        ))?;
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let outpath = match file.enclosed_name() {
                Some(path) => path,
                None => continue,
            };
            emit(format!(
                "cargo:debug=Extracting: {outpath}",
                outpath = outpath.display()
            ))?;
            if file.is_dir() {
                fs::create_dir_all(&outpath)?;
            } else {
                if let Some(parent) = outpath.parent() {
                    if !parent.exists() {
                        fs::create_dir_all(parent)?;
                    }
                }
                let mut outfile = fs::File::create(&outpath)?;
                let bytes_copied = io::copy(&mut file, &mut outfile)?;
                emit(format!("cargo:debug=  -> wrote {bytes_copied} bytes"))?;
            }
        }
        emit(format!(
            "cargo:debug=Extraction complete. {lib_name} exists = {exists}",
            exists = Path::new(lib_name).exists()
        ))?;
    }

    emit(format!(
        "cargo:debug=Directory contents of {install_dir}:",
        install_dir = install_dir.display()
    ))?;
    if let Ok(entries) = fs::read_dir(&install_dir) {
        for entry in entries.flatten() {
            emit(format!(
                "cargo:debug=  - {entry}",
                entry = entry.path().display()
            ))?;
        }
    }

    if !Path::new("duckdb.h").exists() {
        emit("cargo:warning=duckdb.h missing from archive; attempting to download...")?;
        let headers_url = format!(
            "https://github.com/duckdb/duckdb/releases/download/v{version}/duckdb-{dist}.zip"
        );
        let response = ensure_http_client(&mut client)?.get(&headers_url).send()?;
        let bytes = response.bytes()?;
        let cursor = Cursor::new(bytes);
        let mut archive = ZipArchive::new(cursor)?;
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            if let Some(enclosed_name) = file.enclosed_name() {
                if enclosed_name == Path::new("duckdb.h")
                    || enclosed_name == Path::new("duckdb.hpp")
                {
                    let mut outfile = fs::File::create(&enclosed_name)?;
                    io::copy(&mut file, &mut outfile)?;
                }
            }
        }
    }

    let lib_dir = install_dir.display();
    let mut env_content = "# Generated by build.rs\n".to_string();
    env_content.push_str(&format!("export DUCKDB_VERSION='{version}'\n"));
    env_content.push_str(&format!(
        "export DUCKDB_PREFIX=\"${{DUCKDB_PREFIX:-{cache_dir}}}\"\n",
        cache_dir = cache_dir.display()
    ));
    env_content.push_str("export DUCKDB_LIB_DIR=\"${DUCKDB_PREFIX}/${DUCKDB_VERSION}\"\n");
    env_content.push_str("export DUCKDB_INCLUDE_DIR=\"${DUCKDB_LIB_DIR}\"\n");
    match dist.as_str() {
        "osx-universal" => {
            env_content.push_str(
                "export DYLD_FALLBACK_LIBRARY_PATH=\"${DUCKDB_LIB_DIR}:${DYLD_FALLBACK_LIBRARY_PATH:-}\"\n",
            );
        }
        "linux-amd64" | "linux-arm64" => {
            env_content
                .push_str("export LD_LIBRARY_PATH=\"${DUCKDB_LIB_DIR}:${LD_LIBRARY_PATH:-}\"\n");
        }
        _ => {}
    }
    fs::write(&env_file, env_content)?;

    emit(format!(
        "cargo:lib_dir={install_dir}",
        install_dir = install_dir.display()
    ))?;
    emit(format!(
        "cargo:env_file={env_file}",
        env_file = env_file.display()
    ))?;
    emit(format!("cargo:duckdb_version={version}"))?;

    emit(format!(
        "cargo:warning=DuckDB {version} ready at {install_dir}",
        install_dir = install_dir.display()
    ))?;

    emit(format!("cargo:rustc-link-search=native={lib_dir}"))?;
    emit("cargo:rustc-link-lib=dylib=duckdb")?;
    emit(format!("cargo:rustc-link-arg=-Wl,-rpath,{lib_dir}"))?;

    Ok(())
}

fn detect_dist() -> BuildResult<String> {
    let os = env::consts::OS;
    let arch = env::consts::ARCH;
    match os {
        "macos" => match arch {
            "aarch64" | "x86_64" => Ok("osx-universal".to_string()),
            _ => Err(Into::into(io::Error::other(format!(
                "Unsupported macOS architecture: {arch}"
            )))),
        },
        "linux" => match arch {
            "x86_64" => Ok("linux-amd64".to_string()),
            "aarch64" => Ok("linux-arm64".to_string()),
            _ => Err(Into::into(io::Error::other(format!(
                "Unsupported Linux architecture: {arch}"
            )))),
        },
        _ => Err(Into::into(io::Error::other(format!(
            "Unsupported operating system: {os}"
        )))),
    }
}

fn ensure_http_client(client: &mut Option<Client>) -> BuildResult<&Client> {
    if client.is_none() {
        *client = Some(
            Client::builder()
                .timeout(Duration::from_secs(600))
                .build()?,
        );
    }

    client
        .as_ref()
        .ok_or_else(|| io::Error::other("HTTP client should be initialized before use").into())
}

fn resolve_duckdb_version(manifest_dir: &Path) -> BuildResult<String> {
    if let Ok(version) = env::var("DUCKDB_VERSION") {
        return Ok(version);
    }

    if let Some(lock_path) = find_cargo_lock(manifest_dir) {
        emit(format!(
            "cargo:rerun-if-changed={lock_path}",
            lock_path = lock_path.display()
        ))?;
        if let Some(version) = duckdb_version_from_lock(&lock_path) {
            return Ok(version);
        }
        emit(format!(
            "cargo:warning=Unable to infer DuckDB version from {lock_path}; falling back to {fallback}",
            lock_path = lock_path.display(),
            fallback = FALLBACK_DUCKDB_VERSION
        ))?;
    } else {
        emit(format!(
            "cargo:warning=Unable to locate Cargo.lock; falling back to {FALLBACK_DUCKDB_VERSION}"
        ))?;
    }

    Ok(FALLBACK_DUCKDB_VERSION.to_string())
}

fn find_cargo_lock(manifest_dir: &Path) -> Option<PathBuf> {
    manifest_dir
        .ancestors()
        .map(|dir| dir.join("Cargo.lock"))
        .find(|candidate| candidate.is_file())
}

fn duckdb_version_from_lock(lock_path: &Path) -> Option<String> {
    let lock = fs::read_to_string(lock_path).ok()?;
    let mut current_name: Option<String> = None;
    let mut current_version: Option<String> = None;
    let mut best_version: Option<String> = None;

    for line in lock.lines().map(str::trim) {
        if line == "[[package]]" {
            if current_name.as_deref() == Some("libduckdb-sys") {
                best_version = pick_newer_version(best_version, current_version.take());
            }
            current_name = None;
            current_version = None;
            continue;
        }

        if let Some(name) = parse_quoted_kv(line, "name") {
            current_name = Some(name);
            continue;
        }

        if let Some(version) = parse_quoted_kv(line, "version") {
            current_version = Some(version);
        }
    }

    if current_name.as_deref() == Some("libduckdb-sys") {
        best_version = pick_newer_version(best_version, current_version);
    }

    best_version
}

fn parse_quoted_kv(line: &str, key: &str) -> Option<String> {
    let prefix = format!("{key} = \"");
    if !line.starts_with(&prefix) {
        return None;
    }
    line.strip_prefix(&prefix)?
        .strip_suffix('"')
        .map(|s| s.to_string())
}

fn pick_newer_version(current: Option<String>, candidate: Option<String>) -> Option<String> {
    match (current, candidate) {
        (None, Some(candidate)) => Some(candidate),
        (Some(current), None) => Some(current),
        (None, None) => None,
        (Some(current), Some(candidate)) => {
            match (semver_triplet(&current), semver_triplet(&candidate)) {
                (Some(a), Some(b)) if b > a => Some(candidate),
                _ => Some(current),
            }
        }
    }
}

fn semver_triplet(version: &str) -> Option<(u64, u64, u64)> {
    let core = version.split_once('-').map(|(v, _)| v).unwrap_or(version);
    let mut parts = core.split('.');
    let major = parts.next()?.parse().ok()?;
    let minor = parts.next()?.parse().ok()?;
    let patch = parts.next()?.parse().ok()?;
    Some((major, minor, patch))
}
