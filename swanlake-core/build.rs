use reqwest::blocking::Client;
use std::env;
use std::fs;
use std::io::Cursor;
use std::path::Path;
use std::time::Duration;
use zip::ZipArchive;

fn main() {
    let version = env::var("DUCKDB_VERSION").unwrap_or_else(|_| "1.4.1".to_string());
    let root_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let cache_dir = Path::new(&root_dir).join(".duckdb");
    let install_dir = cache_dir.join(&version);
    let env_file = cache_dir.join("env.sh");

    let client = Client::builder()
        .timeout(Duration::from_secs(600))
        .build()
        .unwrap();

    let dist = detect_dist().expect("Unsupported platform");
    let zip_name = format!("libduckdb-{}.zip", dist);
    let download_url = format!(
        "https://github.com/duckdb/duckdb/releases/download/v{}/{}",
        version, zip_name
    );

    fs::create_dir_all(&install_dir).unwrap();
    env::set_current_dir(&install_dir).unwrap();

    if !Path::new(&zip_name).exists() {
        println!("cargo:warning=Downloading DuckDB {} ({})...", version, dist);
        let response = client
            .get(&download_url)
            .send()
            .expect("Failed to download DuckDB");
        let bytes = response.bytes().expect("Failed to read response bytes");
        fs::write(&zip_name, bytes).expect("Failed to write zip file");
    } else {
        println!("cargo:warning=Using cached archive {}", zip_name);
    }

    // Check for platform-specific library
    let lib_name = if cfg!(target_os = "macos") {
        "libduckdb.dylib"
    } else {
        "libduckdb.so"
    };
    let lib_exists = Path::new(lib_name).exists();
    println!(
        "cargo:debug=Checking for library in {}: {} exists = {}",
        install_dir.display(),
        lib_name,
        lib_exists
    );

    if !lib_exists {
        println!("cargo:warning=Extracting {}...", zip_name);
        let file = fs::File::open(&zip_name).unwrap();
        let mut archive = ZipArchive::new(file).unwrap();
        println!("cargo:debug=Archive contains {} files", archive.len());
        for i in 0..archive.len() {
            let mut file = archive.by_index(i).unwrap();
            let outpath = match file.enclosed_name() {
                Some(path) => path,
                None => continue,
            };
            println!("cargo:debug=Extracting: {}", outpath.display());
            if file.is_dir() {
                fs::create_dir_all(&outpath).unwrap();
            } else {
                if let Some(p) = outpath.parent() {
                    if !p.exists() {
                        fs::create_dir_all(p).unwrap();
                    }
                }
                let mut outfile = fs::File::create(&outpath).unwrap();
                let bytes_copied = std::io::copy(&mut file, &mut outfile).unwrap();
                println!("cargo:debug=  -> wrote {} bytes", bytes_copied);
            }
        }
        println!(
            "cargo:debug=Extraction complete. {} exists = {}",
            lib_name,
            Path::new(lib_name).exists()
        );
    } else {
        println!("cargo:warning=Using cached library files");
    }

    // List directory contents for debugging
    println!(
        "cargo:debug=Directory contents of {}:",
        install_dir.display()
    );
    if let Ok(entries) = fs::read_dir(&install_dir) {
        for entry in entries.flatten() {
            println!("cargo:debug=  - {}", entry.path().display());
        }
    }

    if !Path::new("duckdb.h").exists() {
        println!("cargo:warning=duckdb.h missing from archive; attempting to download...");
        let headers_url = format!(
            "https://github.com/duckdb/duckdb/releases/download/v{}/duckdb-{}.zip",
            version, dist
        );
        let response = client
            .get(&headers_url)
            .send()
            .expect("Failed to download headers");
        let bytes = response.bytes().unwrap();
        let cursor = Cursor::new(bytes);
        let mut archive = ZipArchive::new(cursor).unwrap();
        for i in 0..archive.len() {
            let mut file = archive.by_index(i).unwrap();
            if let Some(enclosed_name) = file.enclosed_name() {
                if enclosed_name == Path::new("duckdb.h")
                    || enclosed_name == Path::new("duckdb.hpp")
                {
                    let mut outfile = fs::File::create(&enclosed_name).unwrap();
                    std::io::copy(&mut file, &mut outfile).unwrap();
                }
            }
        }
    }

    let lib_dir = install_dir.display();
    let mut env_content = "# Generated by build.rs\n".to_string();
    env_content.push_str(&format!("export DUCKDB_VERSION='{}'\n", version));
    env_content.push_str(&format!(
        "export DUCKDB_PREFIX=\"${{DUCKDB_PREFIX:-{}}}\"\n",
        cache_dir.display()
    ));
    env_content.push_str("export DUCKDB_LIB_DIR=\"${DUCKDB_PREFIX}/${DUCKDB_VERSION}\"\n");
    env_content.push_str("export DUCKDB_INCLUDE_DIR=\"${DUCKDB_LIB_DIR}\"\n");
    match dist.as_str() {
        "osx-universal" => {
            env_content.push_str(
                "export DYLD_FALLBACK_LIBRARY_PATH=\"${DUCKDB_LIB_DIR}:${DYLD_FALLBACK_LIBRARY_PATH:-}\"\n",
            );
        }
        "linux-amd64" | "linux-arm64" => {
            env_content
                .push_str("export LD_LIBRARY_PATH=\"${DUCKDB_LIB_DIR}:${LD_LIBRARY_PATH:-}\"\n");
        }
        _ => {}
    }
    fs::write(&env_file, env_content).unwrap();

    // Propagate metadata to dependent crates for easier runtime linking
    println!("cargo:lib_dir={}", install_dir.display());
    println!("cargo:env_file={}", env_file.display());
    println!("cargo:duckdb_version={}", version);

    println!(
        "cargo:warning=DuckDB {} ready at {}",
        version,
        install_dir.display()
    );

    // Set Cargo link paths for dynamic linking
    println!("cargo:rustc-link-search=native={}", lib_dir);
    println!("cargo:rustc-link-lib=dylib=duckdb");
    println!("cargo:rustc-link-arg=-Wl,-rpath,{}", lib_dir);
}

fn detect_dist() -> Result<String, String> {
    let os = env::consts::OS;
    let arch = env::consts::ARCH;
    match os {
        "macos" => match arch {
            "aarch64" | "x86_64" => Ok("osx-universal".to_string()),
            _ => Err(format!("Unsupported macOS architecture: {}", arch)),
        },
        "linux" => match arch {
            "x86_64" => Ok("linux-amd64".to_string()),
            "aarch64" => Ok("linux-arm64".to_string()),
            _ => Err(format!("Unsupported Linux architecture: {}", arch)),
        },
        _ => Err(format!("Unsupported operating system: {}", os)),
    }
}
