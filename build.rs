use reqwest::blocking::get;
use std::env;
use std::fs;
use std::io::Cursor;
use std::path::Path;
use zip::ZipArchive;

fn main() {
    let version = env::var("DUCKDB_VERSION").unwrap_or_else(|_| "1.4.1".to_string());
    let root_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let cache_dir = Path::new(&root_dir).join(".duckdb");
    let install_dir = cache_dir.join(&version);
    let env_file = cache_dir.join("env.sh");

    let dist = detect_dist().expect("Unsupported platform");
    let zip_name = format!("libduckdb-{}.zip", dist);
    let download_url = format!(
        "https://github.com/duckdb/duckdb/releases/download/v{}/{}",
        version, zip_name
    );

    fs::create_dir_all(&install_dir).unwrap();
    env::set_current_dir(&install_dir).unwrap();

    if !Path::new(&zip_name).exists() {
        println!("cargo:warning=Downloading DuckDB {} ({})...", version, dist);
        let response = get(&download_url).expect("Failed to download DuckDB");
        let bytes = response.bytes().expect("Failed to read response bytes");
        fs::write(&zip_name, bytes).expect("Failed to write zip file");
    } else {
        println!("cargo:warning=Using cached archive {}", zip_name);
    }

    if !Path::new("libduckdb.dylib").exists() && !Path::new("libduckdb.so").exists() {
        println!("cargo:warning=Extracting {}...", zip_name);
        let file = fs::File::open(&zip_name).unwrap();
        let mut archive = ZipArchive::new(file).unwrap();
        for i in 0..archive.len() {
            let mut file = archive.by_index(i).unwrap();
            let outpath = match file.enclosed_name() {
                Some(path) => path,
                None => continue,
            };
            if file.is_dir() {
                fs::create_dir_all(&outpath).unwrap();
            } else {
                if let Some(p) = outpath.parent() {
                    if !p.exists() {
                        fs::create_dir_all(p).unwrap();
                    }
                }
                let mut outfile = fs::File::create(&outpath).unwrap();
                std::io::copy(&mut file, &mut outfile).unwrap();
            }
        }
    }

    if !Path::new("duckdb.h").exists() {
        println!("cargo:warning=duckdb.h missing from archive; attempting to download...");
        let headers_url = format!(
            "https://github.com/duckdb/duckdb/releases/download/v{}/duckdb-{}.zip",
            version, dist
        );
        let response = get(&headers_url).expect("Failed to download headers");
        let bytes = response.bytes().unwrap();
        let cursor = Cursor::new(bytes);
        let mut archive = ZipArchive::new(cursor).unwrap();
        for i in 0..archive.len() {
            let mut file = archive.by_index(i).unwrap();
            if let Some(enclosed_name) = file.enclosed_name() {
                if enclosed_name == Path::new("duckdb.h")
                    || enclosed_name == Path::new("duckdb.hpp")
                {
                    let mut outfile = fs::File::create(&enclosed_name).unwrap();
                    std::io::copy(&mut file, &mut outfile).unwrap();
                }
            }
        }
    }

    let lib_dir = install_dir.display();
    let include_dir = install_dir.display();
    let mut env_content = "# Generated by build.rs\n".to_string();
    env_content.push_str(&format!("export DUCKDB_LIB_DIR='{}'\n", lib_dir));
    env_content.push_str(&format!("export DUCKDB_INCLUDE_DIR='{}'\n", include_dir));
    match dist.as_str() {
        "osx-universal" => {
            env_content.push_str(&format!(
                "export DYLD_FALLBACK_LIBRARY_PATH='{}:${{DYLD_FALLBACK_LIBRARY_PATH:-}}'\n",
                lib_dir
            ));
        }
        "linux-amd64" | "linux-arm64" => {
            env_content.push_str(&format!(
                "export LD_LIBRARY_PATH='{}:${{LD_LIBRARY_PATH:-}}'\n",
                lib_dir
            ));
        }
        _ => {}
    }
    fs::write(&env_file, env_content).unwrap();

    println!(
        "cargo:warning=DuckDB {} ready at {}",
        version,
        install_dir.display()
    );

    // Set Cargo link paths for dynamic linking
    println!("cargo:rustc-link-search=native={}", lib_dir);
    println!("cargo:rustc-link-lib=dylib=duckdb");
    println!("cargo:rustc-link-arg=-Wl,-rpath,{}", lib_dir);
}

fn detect_dist() -> Result<String, String> {
    let os = env::consts::OS;
    let arch = env::consts::ARCH;
    match os {
        "macos" => match arch {
            "aarch64" | "x86_64" => Ok("osx-universal".to_string()),
            _ => Err(format!("Unsupported macOS architecture: {}", arch)),
        },
        "linux" => match arch {
            "x86_64" => Ok("linux-amd64".to_string()),
            "aarch64" => Ok("linux-arm64".to_string()),
            _ => Err(format!("Unsupported Linux architecture: {}", arch)),
        },
        _ => Err(format!("Unsupported operating system: {}", os)),
    }
}
